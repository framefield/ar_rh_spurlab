#include "Assets/ff/ar_rh_spurlab/LineBuildup/shader/point.hlsl"


#pragma kernel buildup_line_renderer
#pragma kernel clear_unused

// Workaround for the absence of sizeof operator in HLSL
#define SIZEOF_UINT 4
#define SIZEOF_FLOAT3 12

// Parameters
uint p_max_triangle_count;
uint p_interpolation_steps;
float p_time;

// Input points
StructuredBuffer<Point> i_points;

// Output buffer and counter

RWByteAddressBuffer o_vertex_buffer;
RWByteAddressBuffer o_index_buffer;
RWStructuredBuffer<uint> o_counter; // used only for counting

// Vertex buffer accessor
void write_vertex(const uint offset, const float3 p, const float3 n)
{
    const uint addr_p = offset * SIZEOF_FLOAT3 * 2;
    const uint addr_n = addr_p + SIZEOF_FLOAT3;
    o_vertex_buffer.Store3(addr_p, asuint(p));
    o_vertex_buffer.Store3(addr_n, asuint(n));
}

// Index buffer accessor
void write_indices(const uint offset, const uint3 indices)
{
    o_index_buffer.Store3(offset * SIZEOF_UINT, indices);
}



//
// Mesh generation kernel
//

[numthreads(4, 4, 4)]
void buildup_line_renderer(uint3 id : SV_DispatchThreadID)
{
}




//
// Cleanup kernel that clears the unused area of the buffers
//

[numthreads(64, 1, 1)]
void clear_unused(uint id : SV_DispatchThreadID)
{
    while (true)
    {
        const uint count = o_counter.IncrementCounter();
        if (count >= p_max_triangle_count) break;
        const uint vertex_idx = count * 3;
        write_vertex(vertex_idx + 0, 0, 0);
        write_vertex(vertex_idx + 1, 0, 0);
        write_vertex(vertex_idx + 2, 0, 0);
        write_indices(vertex_idx, uint3(0, 0, 0));
    }
}
