using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR.ARFoundation;

namespace ff.ar_rh_spurlab.Calibration
{
    /// <summary>
    /// This plane visualizer demonstrates the use of a feathering effect
    /// at the edge of the detected plane, which reduces the visual impression
    /// of a hard edge.
    /// </summary>
    [RequireComponent(typeof(ARPlaneMeshVisualizer), typeof(MeshRenderer), typeof(ARPlane))]
    public class PlaneMeshVisualizer : MonoBehaviour
    {
        [Tooltip("The width of the texture feathering (in world units).")]
        [SerializeField]
        private float _featheringWidth = 0.2f;

        private void Awake()
        {
            _planeMeshVisualizer = GetComponent<ARPlaneMeshVisualizer>();
            _meshRenderer = GetComponent<MeshRenderer>();
            _plane = GetComponent<ARPlane>();
            _propertyBlock = new MaterialPropertyBlock();
        }

        private void OnEnable()
        {
            _plane.boundaryChanged += ARPlane_boundaryUpdated;
        }

        private void OnDisable()
        {
            _plane.boundaryChanged -= ARPlane_boundaryUpdated;
        }

        private void ARPlane_boundaryUpdated(ARPlaneBoundaryChangedEventArgs eventArgs)
        {
            GenerateBoundaryUVs(_planeMeshVisualizer.mesh);
        }

        /// <summary>
        /// Generate UV2s to mark the boundary vertices and feathering UV coords.
        /// </summary>
        /// <remarks>
        /// The <c>ARPlaneMeshVisualizer</c> has a <c>meshUpdated</c> event that can be used to modify the generated
        /// mesh. In this case we'll add UV2s to mark the boundary vertices.
        /// This technique avoids having to generate extra vertices for the boundary. It works best when the plane is
        /// is fairly uniform.
        /// </remarks>
        /// <param name="mesh">The <c>Mesh</c> generated by <c>ARPlaneMeshVisualizer</c></param>
        private void GenerateBoundaryUVs(Mesh mesh)
        {
            var vertexCount = mesh.vertexCount;

            // Reuse the list of UVs
            FeatheringUVs.Clear();
            if (FeatheringUVs.Capacity < vertexCount)
            {
                FeatheringUVs.Capacity = vertexCount;
            }

            mesh.GetVertices(Vertices);

            var centerInPlaneSpace = Vertices[^1];
            var uv = new Vector3(0, 0, 0);
            var shortestUVMapping = float.MaxValue;

            // Assume the last vertex is the center vertex.
            for (var i = 0; i < vertexCount - 1; i++)
            {
                var vertexDist = Vector3.Distance(Vertices[i], centerInPlaneSpace);

                // Remap the UV so that a UV of "1" marks the feathering boundary.
                // The ratio of featherBoundaryDistance/edgeDistance is the same as featherUV/edgeUV.
                // Rearrange to get the edge UV.
                var uvMapping = vertexDist / Mathf.Max(vertexDist - _featheringWidth, 0.001f);
                uv.x = uvMapping;

                // All the UV mappings will be different. In the shader we need to know the UV value we need to fade out by.
                // Choose the shortest UV to guarantee we fade out before the border.
                // This means the feathering widths will be slightly different, we again rely on a fairly uniform plane.
                if (shortestUVMapping > uvMapping)
                {
                    shortestUVMapping = uvMapping;
                }

                FeatheringUVs.Add(uv);
            }

            // Add the center vertex UV
            uv.Set(0, 0, 0);
            FeatheringUVs.Add(uv);

            mesh.SetUVs(1, FeatheringUVs);
            mesh.UploadMeshData(false);

            _propertyBlock.SetFloat(ShortestUVMappingPropId, shortestUVMapping);
            _propertyBlock.SetFloat(IsWallPropId, _plane.normal.y < 0.5f ? 1 : 0);
            _meshRenderer.SetPropertyBlock(_propertyBlock);
        }

        private static readonly List<Vector3> FeatheringUVs = new();
        private static readonly List<Vector3> Vertices = new();

        private ARPlaneMeshVisualizer _planeMeshVisualizer;
        private ARPlane _plane;
        private MeshRenderer _meshRenderer;
        private MaterialPropertyBlock _propertyBlock;

        private static readonly int ShortestUVMappingPropId = Shader.PropertyToID("_ShortestUVMapping");
        private static readonly int IsWallPropId = Shader.PropertyToID("_isWall");
    }
}
